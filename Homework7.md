# Homework 7
## Allie McFarland

1. Testing should occur during every stage. When looking at the requirements, you should check thoroughly to make sure that all requirements that are needed are present. During the design phase, you need to make sure that it is accurate and considers the requirements. While implementing, each artifact needs to be tested individually. Afterwards the program needs to be tested as a whole to ensure that it meets all requirements.
2. If I was asked to have verification in the code, I would take the input and compare it to information in a database to make sure it is correct. For example, if I ask for the password for the user, I would then check it against the database to ensure it is correct. If I was asked to have validation in the code, I would put in checks to make sure input was in the correct format. For example, if I ask for an person's age, I would first make sure it is an int and not the number spelt out or a float, then I would check if the value is between 0 and 130, since any more or any less is impossible. In terms of the entire workflow, verification would be the process of determining if the workflow had been carried out correctly. Validation would making sure the product meets the requirements.
3. A major difference between the two is the use of testing cases. Execution-based testing uses them while non-execution-based testing does not. Non-execution-based testing involves carefully reading through the code, and finding faults. The faults would be corrected at a later time. Execution-based testing involves using test cases. Once you get the output, it should be compared to the expected output. If it does not match, then there is definitely a fault in the code. If it matches, however, it does not ensure that there is no faults. There still could be a bug somewhere in the code.
4. Quality refers to the extent the product satisfies the requirements. It can also include how well designed and meticulously coded the product is for later maintenance.
5. People can have blind-spots when working with thier own code. They have thought about the code for so long that they may not realize a part contains a fault. When I was in high school and had to do a lot of essays, I would always get someone else to proofread my paper. I know I am not a good speller, so often I would read through the paper and not see an incorrectly spelt word. Someone else would be able to catch it. They can also tell me if a particular section doesn't make sense. I know what is going on, but someone who hasn't done the research may not understand the connections that I am trying to make. It helps me find areas of improvement from the prospective of the average person.
6. A correctness proof is a mathematical technique for showing a product satsfies its specifications. Execution testing involves getting the output from test cases and comparing the output gained from the test to the expected output. I don't think there is a "better" one. They both contain thier own advantages and disadavantages. It would depend on the type of program being developed.
7. This article brought up several important points. We focus too much on getting the code to work and not enough time on the logic behind it. At the beginning it talked about the "spaghetti" code in the car's code. It reminded me of my game. I have been in Games Programming I this semester, and as such I have had to use both Unity and C++ for the first time. A lot of the code written in the beginning was attempt after attempt to get it to do what I wanted it to do. Recently, I decided rather than continue this pattern to fix a problem that was occuring, I would just scrap all the code and rewrite it. The code that took days worth of work between a month took a single day to rewrite, and I fixed the problem without finding out what was causing it. I even completely threw away one of my scripts because I found it wasn't necessary. It's code made more sense to do it in another script.
8. I think there will be a "software apocalypse" if people try to continue programming the way they have been doing. I don't see myself doing anything major to address the concerns, but I will advocate planning before you code. Before this class, I wouldn't really have a plan before I start coding. I would just go for it. Since starting this class, I have found myself solving some of the more difficult problems on paper. They are helpful for the short-term. I don't think I would understand what they mean if I was to look at them in a year, but the plan is definitely helpful.