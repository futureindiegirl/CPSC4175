# Homework 10
## Allie McFarland

1. There is the planning for the whole project and the planning that comes at the end of the requirements phase. Two examples of planning for the whole project might include the techniques used to gather requirements and how testing will occur. Two examples of planning at the end of the requirements phase is cost estimations and duration estimations.
2. Before requirements the range is 4, before analysis the range is 2.5, before design the range is 1.5, and before implementation the range is closer to 1.1 or 1.2. The uncertainty is exponential the earlier you give an estimate.
3. The two types of costs are internal cost and external cost. Internal cost is the cost to the developers, for example, salaries and hardware costs. External costs is the price the client will pay, for example, the profit margin or selling under cost to gain a client. 
4. A code generator, like a GUI generator can produce thousands of line of code in a very small amount of time. Using visual studio, I was trying to do something and found the code that the GUI I was working on generated. It was really long and I hadn't been working on the project for very long. Code implemented may not all go to the client. In my project we had a class that just helped us generate debit card numbers. It is very difficult to count lines if you have to decide what counts as a line. I may say that all lines in a method count but someone else may only count the call. There is more to making the product than just coding it. A couple of weeks ago, I had an assignment where I had to change the code that we worked on in class to do something. I spent a good few hours on it, but only ended up introducing/changing 8 lines of code.
5. The basic formula seems to be the same, unadjusted function points times technical complexity factor. The difference is in the way the TFC is found. Some put different values for different parts.
6. I chose quality assurance. It provides plans for ensuring the project meets it specifications. It needs to indicate what procedures would occur and the relationship between them. 
7. I may document an explanation for each major function, each major varible, and each class. It would give me a glimpse later on at what I was doing. I've found myself looking back at some of my earlier programs and not knowing what was going on. Documenting my code could have prevented that.
8. Documentation describes what the function takes as input, what it does, and what it outputs. You must know what your function does to write effective documentation. If do not write the documentation, you cannot prove you even wrote it yourself to begin with.