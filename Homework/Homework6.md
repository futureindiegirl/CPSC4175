#Homework 6
##Allie McFarland

1. If I wanted to do something object oriented, I would use java. If I wanted something more procedural, I would use c. Say I wanted to make a text based card game. Java would be more appropriate because I can make objects for cards and decks. Then I would just have to pass the card objects to where they need to be. It would be much harder to do that in a language like c.  If I wanted to do something more procedural, I would use c. While Java could do what I want, it just seems like a lot more work. C is also looser in a way. In operating systems, my teacher introduced us to euler. It is basically math problems that can really only be solved by computers. I really like trying to figure all of the answers, but I can only seem to do them in c. Java always has a problem with something no matter what I am trying to do. The problem I last worked on called worked, but is entirely too slow. Java won't let it run at all.
2. Don't use multiple names that end up meaning the same thing. Don't use two words that mean the same thing in the same program, like average and mean. Don't change the ordering in your names, like timeStart and finishTime. Document your code, but don't necessarily do self documenting code. A super long name like xCoordinateOfPositionOfRobotArm is too long if it is used many times, but xCoor is can be confusing on what it is referring to. Use constants rather than hard coded values. While it may not change often, if it did it would be annoying to change all instants of it. Don't crowd all code together. An example would be:
if(true){
x+=3
y*=7
z=x/y}
It is difficult to read. Don't use nested if statements more than 3 deep. It then becomes harder to find where the error is.
3. On Drupal.org, some of the standards are to leave a space before and after all operators, lines should not be longer than 80 characters, conditions should not be wrapped to multiple lines, and space between space and the next parameter in a function call. Another set of coding standards is Shopware. Some of the standards include using 4 spaces instead of a tab, using single quotes, having a space after keywords, no padding(blank lines), using unused variables, space after commas, and wrap conditional assignments in parenthesis. I prefer Drupal's coding standards, because a lot of it is what I do anyway. I feel it makes easy to read code. Shopware's has some rules that can lead to harder to read code, like avoiding blank lines. They can be very helpful when trying to find where you do a specific thing. If I have a method that is doing multiple things to get the output, I will add blank lines when I switch what I am doing.
4. When I was in Data Structures, a chunk of our time was spent on sorting algorithms. We had to code them ourselves. A lot of them involved swapping two values in an array, so when we got to the second algorithm, I moved the code to swap to its own method.
5. A stub is an empty artifact. It means that it doesn't really do anything yet and just return a value or prints a message. A driver is something that calls an artifact. I have used both before. Often, if I can anticipate a method being required, I will make a stub so that I can focus on more difficult parts first. I often use a driver to test the code, writing it so that I know what I should get compared to what I actually get.
6. One strength of top-down integration is fault isolation. If you code artifact A and it passes the test, but after coding artifact B it fails, you can narrow down where the fault is to either in artifact B or in the interface between the two. Another strength is that major design flaws show up early. If you code the logic first before the operations, design faults can be detected. You can see what needs to be changed for before continueing to coding the operations. A weakness is that a potential reusable code artifact may not be adequately tested. Someone may assume that it is correct and waste time trying to find faults in other places. It may be better just to rewrite it.
7. One strength of bottom-up intergration is that it can be tested with drivers rather than fault shielding artifacts. Another strength is fault isolation, similar to top-down intergration. A weakness is that design faults are detected late in the workflow. It then takes a lot of time to redesign and recode. 
8. Sandwich integration is where logical artifacts are integrated top-down and operational artifacts are integrated bottom-up. DSL promotes it because it can act as a glue between lower level languages and higher level languages. You could implement the more logical aspects of your software in a higher level language top-down, and the more operational aspects in a lower level language bottom-up. You can then use a DSL to pass what needs to be passed between the two sections/languages and you can avoid the problems associated with using just top-down or just bottom-up strategies.
9. Testing carried out by the implementation group is called white-box testing. The program is tested ignoring the specifications. Testing carried out by the SQA group is called black-box testing. The program is tested ignoring the code. Both are very necessary. The program needs to be error free, but also be as the client specified.
10. While I cannot say I am very confident that I understand what he is saying, I think understand the gist. A large part of the letter is addressing how a process progresses. In the beginning of the letter, he says that while a programmer is working on the program, he has certain control over the process. Afterwards, the process is made by the machine. He says it can be very difficult to follow the flow of the process when a lot of goto statements are used. He basically says that it is easier to follow the progress when it is a sequence of textual indices rather than trying to figure out all the moments a certain action happens in the code. 