# Homework 5
## Allie McFarland
1. The two basic ways of designing a product are operation-oriented design and data-oriented design. Operation-oriented design techniques emphasizes operations first, data second. Data-oriented design focus on data rather than operations.
2. For the acrhitectural design, the input is the sepecifications document and the output is a list of modules and description on how they are connected. The specification document is important because it tell you what the program is supposed to do. You need to know that if you plan to design something to do it. The list of modules is important because you need to know the classes you will need to implement all the requirements. You also need to know how they will connect later on. For the detailed design, the inputs are the list of modules and the output is a set of designed modules. The designed modules will be how the program is implemented later on. The designed modules and the description of how they are connected are an important part of the design document.
3. I am not sure what is meant by graduation requirements, so I assume it means having passing grades and enough credits. I would have variables for the classes, the grades needed to pass, and the credit obtained from passing.
4. There would be one that would check if the class was passed. There would be one to print the amount of credits obtained, the classes that was passed, and if the student can graduate.
5. I would have a class for classes. It would have attributes for the name of the class, grade needed to pass the class, the grade the student earned, and the number of credits the class is worth. It would have the appropriate get and set methods and it would have a method that would return true or false depending on if the student passed the class.
6. The statement "the design workflow can be considered an iterative, spiral process in itself" makes me think it means that you work on it until it is as perfect as possible. The way we have been doing it in class, we have worked on chunks at a time. In some ways, I think that the first approach would be more appropriate because an ATM is more static. The main functions wouldn't majorly change very often, so you would be able to work on each phase until it is just right. Looking back that is what I would probably do if it was my job. However, this is a class project. We are learning as we go. We were even asked to do much of the first iteration without exactly knowing what to do. In this way it is much better to do it in the way we have been. I have been realizing many other aspects of an ATM that I wouldn't normally have considered. So it has been changing often.
7. When you test an implementation, you are making sure your code is doing what it is supposed to be doing. When you are testing the design, you are testing the logic of it. If I had to test a design, I would probably take the use cases and make sure that everything works from a logic standpoint. I would think about every possible action that would need to be taken and ask if it works according to the design. If I can ask myself "but what if I... what would happen? what would the program do?" and I can not find an answer to it in the design then there would be an area of improvement for the design.
8. According to the book, the cyclomatic complexity is the number of binary decisions plus one, so the cyclomatic complexity would be 3.
9. I used ArgoUML. I think it really cool. I found a tutorial online and followed it. It was really easy to make each class and make the associations. I also like how you can then generate code. It places all of the attributes and operation for you so all you have to do is fill in the operations.
10. I really liked the article. I never thought about how often software breaks until I started programming. I have a tendency to use thing in a way that was not quite intended. For example, a game that I like to play runs in real time, so I often leave it on in the background. Since Windows 10, there has been a visual glitch where if I use the windows key to look at another window, when I come back the game has a blue tint to it. It is still playable beyond not being able to see as well. This kind of software is not vital, but there are so many other softwares that do and have just as many bugs. I cannot believe that software can be sold with as many bugs as it usually has. The article said that the SEI ranks 70% of software organizations as "chaos or slightly better than chaos." I almost don't want to know how many error are in software like banking so I can continue living in blissful ignorance. 